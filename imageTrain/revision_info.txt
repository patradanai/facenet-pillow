arguments: f:/Vison/Face_Recognition/preprocessing.py
--------------------
tensorflow version: 1.15.0
--------------------
git hash: b'682680259522d75b9d3f03596c43bc906ac68147'
--------------------
b'diff --git a/__pycache__/facenet.cpython-37.pyc b/__pycache__/facenet.cpython-37.pyc\nindex 1bacc96..9a5f11d 100644\nBinary files a/__pycache__/facenet.cpython-37.pyc and b/__pycache__/facenet.cpython-37.pyc differ\ndiff --git a/facenet.py b/facenet.py\nindex 926bf8c..14e935a 100644\n--- a/facenet.py\n+++ b/facenet.py\n@@ -98,7 +98,10 @@ def shuffle_examples(image_paths, labels):\n \n def random_rotate_image(image):\n     angle = np.random.uniform(low=-10.0, high=10.0)\n-    return misc.imrotate(image, angle, \'bicubic\')\n+    rotate = Image.open(image)\n+    rotate = np.array(rotate.rotate(angle, Image.BICUBIC))\n+    return rotate\n+    # misc.imrotate(image, angle, \'bicubic\')\n \n \n # 1: Random rotate 2: Random crop  4: Random flip  8:  Fixed image standardization  16: Flip\ndiff --git a/preprocessing.py b/preprocessing.py\nindex cf7ac9e..6624dc0 100644\n--- a/preprocessing.py\n+++ b/preprocessing.py\n@@ -1,18 +1,18 @@\n """Performs face alignment and stores face thumbnails in the output directory."""\n # MIT License\n-# \n+#\n # Copyright (c) 2016 David Sandberg\n-# \n+#\n # Permission is hereby granted, free of charge, to any person obtaining a copy\n # of this software and associated documentation files (the "Software"), to deal\n # in the Software without restriction, including without limitation the rights\n # to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n # copies of the Software, and to permit persons to whom the Software is\n # furnished to do so, subject to the following conditions:\n-# \n+#\n # The above copyright notice and this permission notice shall be included in all\n # copies or substantial portions of the Software.\n-# \n+#\n # THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n # IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n # FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n@@ -35,6 +35,7 @@ import align.detect_face\n import random\n from time import sleep\n \n+\n class preprocessing():\n     """\n         inputPath=\'Directory with unaligned images.\')\n@@ -45,7 +46,8 @@ class preprocessing():\n         orderRandom=\'Upper bound on the amount of GPU memory that will be used by the process.\', default=1.0)\n         multipleFace=\'Detect and align multiple faces per image.\', default=False)\n     """\n-    def __init__(self,inputPath,outputPath,gpuFaction=1,marginSize=44,imageSize=182,multipleFace=False,orderRandom=False):\n+\n+    def __init__(self, inputPath, outputPath, gpuFaction=1, marginSize=44, imageSize=182, multipleFace=False, orderRandom=False):\n         self.inputPath = inputPath\n         self.outputPath = outputPath\n         self.gpuFaction = gpuFaction\n@@ -53,33 +55,36 @@ class preprocessing():\n         self.imageSize = imageSize\n         self.multipleFace = multipleFace\n         self.orderRandom = orderRandom\n-        \n+\n     def alignProcessing(self):\n         sleep(random.random())\n         output_dir = os.path.expanduser(self.outputPath)\n         if not os.path.exists(output_dir):\n             os.makedirs(output_dir)\n         # Store some git revision info in a text file in the log directory\n-        src_path,_ = os.path.split(os.path.realpath(__file__))\n+        src_path, _ = os.path.split(os.path.realpath(__file__))\n         facenet.store_revision_info(src_path, output_dir, \' \'.join(sys.argv))\n         dataset = facenet.get_dataset(self.inputPath)\n-        \n+\n         print(\'Creating networks and loading parameters\')\n-        \n+\n         with tf.Graph().as_default():\n-            gpu_options = tf.GPUOptions(per_process_gpu_memory_fraction=self.gpuFaction)\n-            sess = tf.Session(config=tf.ConfigProto(gpu_options=gpu_options, log_device_placement=False))\n+            gpu_options = tf.GPUOptions(\n+                per_process_gpu_memory_fraction=self.gpuFaction)\n+            sess = tf.Session(config=tf.ConfigProto(\n+                gpu_options=gpu_options, log_device_placement=False))\n             with sess.as_default():\n                 pnet, rnet, onet = align.detect_face.create_mtcnn(sess, None)\n-        \n-        minsize = 20 # minimum size of face\n-        threshold = [ 0.6, 0.7, 0.7 ]  # three steps\'s threshold\n-        factor = 0.709 # scale factor\n+\n+        minsize = 20  # minimum size of face\n+        threshold = [0.6, 0.7, 0.7]  # three steps\'s threshold\n+        factor = 0.709  # scale factor\n \n         # Add a random key to the filename to allow alignment using multiple processes\n         random_key = np.random.randint(0, high=99999)\n-        bounding_boxes_filename = os.path.join(output_dir, \'bounding_boxes_%05d.txt\' % random_key)\n-        \n+        bounding_boxes_filename = os.path.join(\n+            output_dir, \'bounding_boxes_%05d.txt\' % random_key)\n+\n         with open(bounding_boxes_filename, "w") as text_file:\n             nrof_images_total = 0\n             nrof_successfully_aligned = 0\n@@ -93,83 +98,100 @@ class preprocessing():\n                         random.shuffle(cls.image_paths)\n                 for image_path in cls.image_paths:\n                     nrof_images_total += 1\n-                    filename = os.path.splitext(os.path.split(image_path)[1])[0]\n-                    output_filename = os.path.join(output_class_dir, filename+\'.png\')\n+                    filename = os.path.splitext(\n+                        os.path.split(image_path)[1])[0]\n+                    output_filename = os.path.join(\n+                        output_class_dir, filename+\'.png\')\n                     print(image_path)\n                     if not os.path.exists(output_filename):\n                         try:\n                             # img = misc.imread(image_path)\n-                            img = np.asarray(Image.open(image_path))\n+                            img = np.array(Image.open(image_path))\n                         except (IOError, ValueError, IndexError) as e:\n                             errorMessage = \'{}: {}\'.format(image_path, e)\n                             print(errorMessage)\n                         else:\n-                            if img.ndim<2:\n+                            if img.ndim < 2:\n                                 print(\'Unable to align "%s"\' % image_path)\n                                 text_file.write(\'%s\\n\' % (output_filename))\n                                 continue\n                             if img.ndim == 2:\n                                 img = facenet.to_rgb(img)\n-                            img = img[:,:,0:3]\n-        \n-                            bounding_boxes, _ = align.detect_face.detect_face(img, minsize, pnet, rnet, onet, threshold, factor)\n+                            img = img[:, :, 0:3]\n+\n+                            bounding_boxes, _ = align.detect_face.detect_face(\n+                                img, minsize, pnet, rnet, onet, threshold, factor)\n                             nrof_faces = bounding_boxes.shape[0]\n-                            if nrof_faces>0:\n-                                det = bounding_boxes[:,0:4]\n+                            if nrof_faces > 0:\n+                                det = bounding_boxes[:, 0:4]\n                                 det_arr = []\n                                 img_size = np.asarray(img.shape)[0:2]\n-                                if nrof_faces>1:\n+                                if nrof_faces > 1:\n                                     if self.multipleFace:\n                                         for i in range(nrof_faces):\n                                             det_arr.append(np.squeeze(det[i]))\n                                     else:\n-                                        bounding_box_size = (det[:,2]-det[:,0])*(det[:,3]-det[:,1])\n+                                        bounding_box_size = (\n+                                            det[:, 2]-det[:, 0])*(det[:, 3]-det[:, 1])\n                                         img_center = img_size / 2\n-                                        offsets = np.vstack([ (det[:,0]+det[:,2])/2-img_center[1], (det[:,1]+det[:,3])/2-img_center[0] ])\n-                                        offset_dist_squared = np.sum(np.power(offsets,2.0),0)\n-                                        index = np.argmax(bounding_box_size-offset_dist_squared*2.0) # some extra weight on the centering\n-                                        det_arr.append(det[index,:])\n+                                        offsets = np.vstack(\n+                                            [(det[:, 0]+det[:, 2])/2-img_center[1], (det[:, 1]+det[:, 3])/2-img_center[0]])\n+                                        offset_dist_squared = np.sum(\n+                                            np.power(offsets, 2.0), 0)\n+                                        # some extra weight on the centering\n+                                        index = np.argmax(\n+                                            bounding_box_size-offset_dist_squared*2.0)\n+                                        det_arr.append(det[index, :])\n                                 else:\n                                     det_arr.append(np.squeeze(det))\n \n                                 for i, det in enumerate(det_arr):\n                                     det = np.squeeze(det)\n                                     bb = np.zeros(4, dtype=np.int32)\n-                                    bb[0] = np.maximum(det[0]-self.marginSize/2, 0)\n-                                    bb[1] = np.maximum(det[1]-self.marginSize/2, 0)\n-                                    bb[2] = np.minimum(det[2]+self.marginSize/2, img_size[1])\n-                                    bb[3] = np.minimum(det[3]+self.marginSize/2, img_size[0])\n-                                    cropped = img[bb[1]:bb[3],bb[0]:bb[2],:]\n+                                    bb[0] = np.maximum(\n+                                        det[0]-self.marginSize/2, 0)\n+                                    bb[1] = np.maximum(\n+                                        det[1]-self.marginSize/2, 0)\n+                                    bb[2] = np.minimum(\n+                                        det[2]+self.marginSize/2, img_size[1])\n+                                    bb[3] = np.minimum(\n+                                        det[3]+self.marginSize/2, img_size[0])\n+                                    cropped = img[bb[1]:bb[3], bb[0]:bb[2], :]\n                                     # scaled = misc.imresize(cropped, (self.imageSize, self.imageSize), interp=\'bilinear\')\n-                                    scaled = np.array(Image.fromarray(cropped).resize((self.imageSize,self.imageSize),Image.BILINEAR))\n+                                    scaled = np.array(Image.fromarray(cropped).resize(\n+                                        (self.imageSize, self.imageSize), Image.BILINEAR))\n                                     nrof_successfully_aligned += 1\n-                                    filename_base, file_extension = os.path.splitext(output_filename)\n+                                    filename_base, file_extension = os.path.splitext(\n+                                        output_filename)\n                                     if self.multipleFace:\n-                                        output_filename_n = "{}_{}{}".format(filename_base, i, file_extension)\n+                                        output_filename_n = "{}_{}{}".format(\n+                                            filename_base, i, file_extension)\n                                     else:\n-                                        output_filename_n = "{}{}".format(filename_base, file_extension)\n+                                        output_filename_n = "{}{}".format(\n+                                            filename_base, file_extension)\n                                     # misc.imsave(output_filename_n, scaled)\n                                     saveFile = Image.fromarray(scaled)\n                                     saveFile.save(output_filename_n)\n-                                    text_file.write(\'%s %d %d %d %d\\n\' % (output_filename_n, bb[0], bb[1], bb[2], bb[3]))\n+                                    text_file.write(\'%s %d %d %d %d\\n\' % (\n+                                        output_filename_n, bb[0], bb[1], bb[2], bb[3]))\n                             else:\n                                 print(\'Unable to align "%s"\' % image_path)\n                                 text_file.write(\'%s\\n\' % (output_filename))\n-                                \n+\n         # print(\'Total number of images: %d\' % nrof_images_total)\n         # print(\'Number of successfully aligned images: %d\' % nrof_successfully_aligned)\n-        return   (nrof_images_total,nrof_successfully_aligned)\n+        return (nrof_images_total, nrof_successfully_aligned)\n \n # def parse_arguments(argv):\n #     parser = argparse.ArgumentParser()\n-    \n+\n #     parser.add_argument(\'input_dir\', type=str, help=\'Directory with unaligned images.\')\n #     parser.add_argument(\'output_dir\', type=str, help=\'Directory with aligned face thumbnails.\')\n #     parser.add_argument(\'--image_size\', type=int,\n #         help=\'Image size (height, width) in pixels.\', default=182)\n #     parser.add_argument(\'--margin\', type=int,\n #         help=\'Margin for the crop around the bounding box (height, width) in pixels.\', default=44)\n-#     parser.add_argument(\'--random_order\', \n+#     parser.add_argument(\'--random_order\',\n #         help=\'Shuffles the order of images to enable alignment using multiple processes.\', action=\'store_true\')\n #     parser.add_argument(\'--gpu_memory_fraction\', type=float,\n #         help=\'Upper bound on the amount of GPU memory that will be used by the process.\', default=1.0)\n@@ -177,14 +199,14 @@ class preprocessing():\n #                         help=\'Detect and align multiple faces per image.\', default=False)\n #     return parser.parse_args(argv)\n \n+\n if __name__ == \'__main__\':\n     input_datadir = \'./imageTest\'\n     output_datadir = \'./imageTrain\'\n \n-    obj=preprocessing(input_datadir,output_datadir)\n-    nrof_images_total,nrof_successfully_aligned=obj.alignProcessing()\n+    obj = preprocessing(input_datadir, output_datadir)\n+    nrof_images_total, nrof_successfully_aligned = obj.alignProcessing()\n \n     print(\'Total number of images: %d\' % nrof_images_total)\n-    print(\'Number of successfully aligned images: %d\' % nrof_successfully_aligned)\n-\n-\n+    print(\'Number of successfully aligned images: %d\' %\n+          nrof_successfully_aligned)'